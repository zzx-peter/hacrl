<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>MaxRL Weight Functions - Interactive Plot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --cmu-red: #C41230;
            --cmu-red-light: rgba(196, 18, 48, 0.2);
            --blue: #0056b3;
            --blue-light: rgba(0, 86, 179, 0.2);
            --gold: #ffb000;
            --gold-light: rgba(255, 176, 0, 0.2);
        }

        body {
            font-family: 'Inter', 'Noto Sans', Arial, sans-serif;
            background-color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: auto;
            margin: 0;
            padding: 24px 20px 0 20px;
        }

        .container {
            width: 480px;
            background: #ffffff;
            padding: 12px 16px 14px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.08);
            text-align: center;
        }

        .container h2 {
            margin: 0 0 8px;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.2px;
            color: #111827;
        }

        .chart-container {
            position: relative;
            height: 240px;
            margin-bottom: 10px;
        }

        .tab-group {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
        }

        .tab {
            padding: 5px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            border: 1px solid #e5e7eb;
            background: #ffffff;
            color: #6b7280;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            flex: 0 0 95px;
            box-sizing: border-box;
        }

        .tab-title {
            font-size: 11px;
        }

        .tab-sub {
            font-size: 9px;
            font-weight: 600;
            color: #374151;
            margin-top: 3px;
        }

        /* When tab is active, ensure sub label follows active (white) color as well. */
        .tab.active .tab-sub {
            /* Keep active sub label dark for readability. */
            color: #111827 !important;
        }

        /* Hover state: use each mode's own color to hint interactivity. */
        .tab[data-mode="rl"]:hover { border-color: rgba(0, 86, 179, 0.4); color: var(--blue); }
        .tab[data-mode="maxrl"]:hover { border-color: rgba(196, 18, 48, 0.4); color: var(--cmu-red); }
        .tab[data-mode="ml"]:hover { border-color: rgba(255, 176, 0, 0.4); color: var(--gold); }

        /* Ensure sub labels follow hover color for better visual cue. */
        .tab[data-mode="rl"]:hover .tab-sub { color: var(--blue); }
        .tab[data-mode="maxrl"]:hover .tab-sub { color: var(--cmu-red); }
        .tab[data-mode="ml"]:hover .tab-sub { color: var(--gold); }

        .tab[data-mode="rl"].active { background: rgba(0, 86, 179, 0.08); color: #111827; border-color: rgba(0, 86, 179, 0.35); }
        .tab[data-mode="maxrl"].active { background: rgba(196, 18, 48, 0.08); color: #111827; border-color: rgba(196, 18, 48, 0.35); }
        .tab[data-mode="ml"].active { background: rgba(255, 176, 0, 0.12); color: #111827; border-color: rgba(255, 176, 0, 0.45); }

        #slider-area {
            margin-top: 10px;
            padding: 6px 8px;
            background: #f8fafc;
            border-radius: 5px;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--cmu-red);
        }

        .val-text { font-family: 'Inter', 'Noto Sans', Arial, sans-serif; font-weight: 600; color: #111827; width: 28px; font-size: 11px; }
    </style>
</head>
<body>

<div class="container">
    <h2>Weight Functions</h2>
    
    <div class="chart-container">
        <canvas id="vizChart"></canvas>
    </div>

    <!-- Legend will now be rendered inside the chart area via Chart.js. -->

    <div class="tab-group">
        <!-- Task: Center three buttons with MaxRL in the middle, and add a second-line description matching vis_weight.html. -->
        <div class="tab" data-mode="rl" onclick="setMode('rl')">
            <span class="tab-title">Standard RL</span>
            <span class="tab-sub">\(T = 1\)</span>
        </div>
        <div class="tab active" data-mode="maxrl" onclick="setMode('maxrl')">
            <span class="tab-title">MaxRL</span>
            <span class="tab-sub">\(T = N\)</span>
        </div>
        <div class="tab" data-mode="ml" onclick="setMode('ml')">
            <span class="tab-title">Maximum Likelihood</span>
            <span class="tab-sub">\(T \to \infty\)</span>
        </div>
    </div>


    <div id="regime-caption" style="margin-top: 6px; font-size: 10px; color:#555; min-height: 1.1em;">
        \(T = N\) (number of rollouts) is what we use in practice.
    </div>

    <div id="slider-area">
        <span style="font-size: 10px; color:#666;">Parameter \(T\)</span>


        <input type="range" id="t-slider" min="0" max="12" step="1" value="5">
        <span id="t-display" class="val-text">32</span>
    </div>
</div>

<script>
    const ctx = document.getElementById('vizChart').getContext('2d');
    const tSlider = document.getElementById('t-slider');
    const tDisplay = document.getElementById('t-display');
    const sliderArea = document.getElementById('slider-area');

    let activeMode = 'maxrl';

    // Task: Use the same mathematical weight functions as in plot.py and keep x,y on log scales.
    // Implementation: sample p in [1e-3, 1 - 1e-3] (log-spaced), then compute:
    //  - J_ML(p)   = 1 / p
    //  - J_GRPO(p) = 1 / sqrt(p (1 - p))
    //  - J_MaxRL^T(p) = (1 - (1 - p)^T) / p

    // Non-linear mapping from slider position to T (English comments as requested).
    // Task: Add more T values to better interpolate toward infinity.
    const T_VALUES = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, Infinity];

    // Core color theme for RL / MaxRL / ML / GRPO.
    const theme = {

        grpo: { normal: '#9BC794', light: 'rgba(155, 199, 148, 0.6)' },
        rl:   { normal: '#0056b3', light: 'rgba(0, 86, 179, 0.4)' },
        maxrl: { normal: '#C41230', light: 'rgba(196, 18, 48, 0.4)' },
        ml: { normal: '#ffb000', light: 'rgba(255, 176, 0, 0.4)' }
    };

    // Task: Draw a compact legend inside the chart area instead of below the plot.
    // Implementation: use a custom plugin to render colored line segments + labels in the top-right corner.
    const inChartLegend = {
        id: 'inChartLegend',
        afterDraw(chart, args, opts) {
            const { ctx, chartArea } = chart;
            if (!chartArea) return;

            const { top, right } = chartArea;

            // Legend items and their colors should match the datasets and textual legend semantics.
            const items = [
                { label: 'MaxRL', color: theme.maxrl.normal },
                { label: 'Standard RL', color: theme.rl.normal },
                { label: 'GRPO', color: theme.grpo.normal },
                { label: 'Maximum Likelihood', color: theme.ml.normal },
            ];

            ctx.save();

            const fontSize = 10;
            ctx.font = `700 ${fontSize}px "Inter", "Noto Sans", Arial, sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            let y = top + 10;
            // Task: Shift in-chart legend slightly left to avoid overlapping with axis labels.
            const x = right - 20;           // anchor text a bit further left
            const lineLength = 15;
            const lineOffset = -5;          // distance from text to start of line

            items.forEach((item) => {
                // Draw line segment with the series color.
                ctx.strokeStyle = item.color;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(x - lineOffset, y);
                ctx.lineTo(x - lineOffset + lineLength, y);
                ctx.stroke();

                // Draw label text.
                ctx.fillStyle = '#111827';
                ctx.fillText(item.label, x, y);

                y += 12; // vertical spacing between legend entries
            });

            ctx.restore();
        }
    };

    // Generate log-spaced p values in (0, 1).
    function generatePValues(n, pMin, pMax) {
        const ps = [];
        const logMin = Math.log(pMin);
        const logMax = Math.log(pMax);
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const logP = logMin + (logMax - logMin) * t;
            ps.push(Math.exp(logP));
        }
        return ps;
    }

    const N_POINTS = 400;
    const P_MIN = 1e-3;
    const P_MAX = 1 - 1e-3;
    const pValues = generatePValues(N_POINTS, P_MIN, P_MAX);

    function wML(p) {
        return 1.0 / p;
    }

    function wGRPO(p) {
        return 1.0 / Math.sqrt(p * (1.0 - p));
    }

    function wMaxRL(p, T) {
        // For T = ∞, approximate with a very large T to avoid numerical issues.
        const effectiveT = (T === Infinity) ? 1e6 : T;
        return (1.0 - Math.pow(1.0 - p, effectiveT)) / p;
    }

    // Standard RL is recovered at T = 1 (same functional form as MaxRL with fixed T = 1).
    function getRLData() {
        return pValues.map(p => ({ x: p, y: wMaxRL(p, 1) }));
    }

    function getMLData() {
        return pValues.map(p => ({ x: p, y: wML(p) }));
    }

    function getGRPOData() {
        return pValues.map(p => ({ x: p, y: wGRPO(p) }));
    }

    function getMaxRLData(T) {
        return pValues.map(p => ({ x: p, y: wMaxRL(p, T) }));
    }

    // Initialize chart with log–log axes and three curves.
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    // MaxRL with adjustable T (drawn first so it is conceptually primary).
                    label: 'J_MaxRL^{(T)}',
                    data: getMaxRLData(T_VALUES[5]),    // default T = 32
                    borderColor: theme.maxrl.normal,
                    borderWidth: 4.5,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // Standard RL corresponds to MaxRL with T = 1.
                    label: 'J_RL',
                    data: getRLData(),
                    borderColor: theme.rl.normal,
                    borderWidth: 3.5,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // GRPO baseline, always shown in green without its own toggle.
                    label: 'J_GRPO',
                    data: getGRPOData(),
                    borderColor: theme.grpo.normal,
                    borderWidth: 3,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // Maximum Likelihood.
                    label: 'J_ML',
                    data: getMLData(),
                    borderColor: theme.ml.normal,
                    borderWidth: 3.5,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 300 },
            scales: {
                x: {
                    type: 'logarithmic',
                    min: P_MIN,
                    max: 1,
                    grid: {
                        color: 'rgba(15, 23, 42, 0.14)',
                        lineWidth: 1.5
                    },
                    // Task: Use clearer math-like axis labels.
                    title: {
                        display: true,
                        text: 'Pass Rate', // pθ(x)
                        font: {
                            size: 11,
                            family: 'Inter, Noto Sans, Arial, sans-serif',
                            weight: '700'
                        },
                        color: '#111827',
                        padding: { top: 2 }
                    },
                    ticks: {
                        font: {
                            size: 9,
                            family: 'Inter, Noto Sans, Arial, sans-serif',
                            weight: '600'
                        },
                        color: '#111827',
                        callback: function(value) {
                            const v = Number(value);
                            if (v === 1e-3 || v === 1e-2 || v === 1e-1 || v === 1) {
                                // Avoid 1e-? style; use decimal notation like 0.1.
                                if (v === 1) return '1';
                                if (v === 1e-1) return '0.1';
                                if (v === 1e-2) return '0.01';
                                if (v === 1e-3) return '0.001';
                            }
                            return '';
                        }
                    }
                },
                y: {
                    type: 'logarithmic',
                    min: 1,
                    max: 1e3,
                    grid: {
                        color: 'rgba(15, 23, 42, 0.14)',
                        lineWidth: 1.5
                    },
                    title: {
                        display: true,
                        text: 'Weight',
                        font: {
                            size: 11,
                            family: 'Inter, Noto Sans, Arial, sans-serif',
                            weight: '700'
                        },
                        color: '#111827',
                        padding: { top: 2 }
                    },
                    ticks: {
                        font: {
                            size: 9,
                            family: 'Inter, Noto Sans, Arial, sans-serif',
                            weight: '600'
                        },
                        color: '#111827',
                        callback: function(value) {
                            const v = Number(value);
                            if (v === 1 || v === 1e1 || v === 1e2 || v === 1e3) {
                                // Avoid 1e style; render as plain integers.
                                if (v === 1) return '1';
                                if (v === 1e1) return '10';
                                if (v === 1e2) return '100';
                                if (v === 1e3) return '1000';
                            }
                            return '';
                        }
                    }
                }
            },
            // Disable built-in legend; we draw a custom legend inside the chart area via plugin.
            plugins: {
                legend: {
                    display: false
                }
            }
        },
        plugins: [inChartLegend]
    });

    function setMode(mode) {
        activeMode = mode;

        // Update tab UI
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tab[data-mode="${mode}"]`).classList.add('active');

        // Update caption text to describe the current T-regime (MathJax-rendered).
        const captionEl = document.getElementById('regime-caption');
        if (captionEl) {
            if (mode === 'rl') {
                captionEl.innerHTML = '\\(T = 1\\) recovers standard reinforcement learning (pass@1).';
            } else if (mode === 'ml') {
                captionEl.innerHTML = '\\(T \\to \\infty\\) recovers exact maximum likelihood.';
            } else {
                captionEl.innerHTML = '\\(T = N\\) (number of rollouts) is what we use in practice.';
            }
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([captionEl]);
            }
        }

        // Task: Keep slider always visible; only change which curve is visually emphasized.
        chart.data.datasets.forEach((ds, idx) => {
            // New dataset index mapping: 0 = MaxRL, 1 = RL, 2 = GRPO, 3 = ML.
            if (idx === 0) {
                ds.borderColor = (mode === 'maxrl') ? theme.maxrl.normal : theme.maxrl.light;
                ds.borderWidth = (mode === 'maxrl') ? 4 : 2.5;
                ds.zIndex = (mode === 'maxrl') ? 10 : 2;
            } else if (idx === 1) {
                ds.borderColor = (mode === 'rl') ? theme.rl.normal : theme.rl.light;
                ds.borderWidth = (mode === 'rl') ? 4 : 2.5;
                ds.zIndex = (mode === 'rl') ? 10 : 2;
            } else if (idx === 2) {
                // GRPO is always shown in the same green style.
                ds.borderColor = theme.grpo.normal;
                ds.borderWidth = 2.5;
                ds.zIndex = 1;
            } else if (idx === 3) {
                ds.borderColor = (mode === 'ml') ? theme.ml.normal : theme.ml.light;
                ds.borderWidth = (mode === 'ml') ? 4 : 2.5;
                ds.zIndex = (mode === 'ml') ? 10 : 2;
            }
        });

        chart.update();
    }

    tSlider.oninput = function() {
        const idx = parseInt(this.value, 10);
        const T = T_VALUES[idx];
        const displayT = (T === Infinity) ? '∞' : T.toString();
        tDisplay.innerText = displayT;

        // Task: Slider should always control the MaxRL curve, regardless of active toggle.
        // With new ordering, dataset index 0 corresponds to the MaxRL^{(T)} curve.
        chart.data.datasets[0].data = getMaxRLData(T);
        chart.update('none'); // No animation during slider drag for smooth interaction.
    };

    // Initialization: set default mode to MaxRL and ensure UI is in sync.
    setMode('maxrl');
</script>

</body>
</html>